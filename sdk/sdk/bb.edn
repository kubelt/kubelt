{:paths []
 :deps {uberdeps/uberdeps {:mvn/version "1.1.2"}}
 :min-bb "0.7.0"
 :tasks
 {:requires
  [[babashka.fs :as fs]
   [babashka.process :as bpr]
   [clojure.edn :as edn]
   [clojure.java.io :as io]
   [clojure.string :as str]]
  :init
  (do
    (def sdk-root (str (fs/canonicalize "..")))
    (defn env [s] (System/getenv s)))
  ;;:enter
  ;;:leave

  ;; TODO version increment during releases

  build:js:develop
  {:doc "Build a development JavaScript version of the SDK"
   :task (shell {:dir sdk-root} "npx shadow-cljs compile sdk")}

  build:js:release
  {:doc "Build a release JavaScript version of the SDK"
   :task (shell {:dir sdk-root} "npx shadow-cljs release sdk")}

  pack:js
  {:doc "Create an npm package"
   :depends [build:js:release]
   :task (shell "npm pack")}

  publish:js
  {:doc "Publish the SDK as an npm package"
   :depends [pack:js]
   :task (let [pack-file (first (fs/glob "." "kubelt-sdk*.tgz"))]
           (if-not pack-file
             (throw (ex-info "missing npm package.tgz")))
           (shell "npm publish" pack-file))}

  ;; Using uberdeps to generate the JAR from a generated deps.edn
  ;; includes Clojure class files, which aren't needed to distribute a
  ;; CLJS library. Try another jar packing tool; in the interim we
  ;; generate a project.clj and rely on lein.
  generate:cljs:deps
  {:doc "Generate a deps.edn from shadow-cljs.edn"
   :task
   (letfn [(to-deps-edn [[k v]]
             [k {:mvn/version v}])]
     (let [shadow-path (str (fs/path sdk-root "shadow-cljs.edn"))
           output-path (str (fs/path sdk-root "deps.edn"))
           ;; Extract dependencies from shadow-cljs.edn
           shadow-reader (java.io.PushbackReader. (io/reader shadow-path))
           shadow-map (edn/read shadow-reader)
           deps-vec (get shadow-map :dependencies [])
           deps-map (into {} (map to-deps-edn deps-vec))
           ;; Build a deps.edn file
           deps-edn {:paths ["src/main"]
                     :dependencies deps-map}]
       (spit output-path (pr-str deps-edn))))}

  pack:cljs:deps
  {:doc "Generate a ClojureScript JAR file using Uberdeps"
   :depends [generate:project]
   :task
   (let [deps-file (str (fs/path sdk-root "deps.edn"))
         output-file "kubelt-sdk.jar"
         parts ["-M" "-m" "uberdeps.uberjar" "--deps-file" deps-file "--target" output-file]
         command (str/join " " parts)]
     (clojure command))}

  ;; TODO generate Apache Maven .m2/settings.xml include GitHub package
  ;; repository setup. User will have to specify their username and
  ;; personal access token and put the file into the right spot.

  ;; TODO generate $HOME/.npmrc configuration

  ;; This is pretty gross. Prefer the deps.edn-based solution once we
  ;; figure out how to generate a JAR with no Clojure dependencies.
  generate:cljs:project
  {:doc "Generate a project.clj from shadow-cljs.edn"
   :task
   (letfn [(wrap [s]
             (str "\"" s "\""))
           (make-project [m]
             (let [n-str (name (:name m))
                   ns-str (namespace (:name m))
                   name-str (str/join "/" [ns-str n-str])
                   coords (str "defproject " name-str " " (wrap (:version m)))
                   description (str/join " " [:description (wrap (:description m))])
                   url (str/join " " [:url (wrap (:url m))])
                   source-paths (str/join " " [:source-paths (:source-paths m)])
                   dependencies (str/join " " [:dependencies (:dependencies m)])
                   repositories (str/join " " [:deploy-repositories (:repositories m)])
                   content (str/join " " [coords
                                          description
                                          url
                                          source-paths
                                          dependencies
                                          repositories])]
               (str "(" content ")")))]
     (let [shadow-path (str (fs/path sdk-root "shadow-cljs.edn"))
           output-path (str (fs/path "project.clj"))
           ;; Extract dependencies from shadow-cljs.edn
           shadow-reader (java.io.PushbackReader. (io/reader shadow-path))
           shadow-map (edn/read shadow-reader)
           ;; Combine the extracted dependencies with a "provided"
           ;; ClojureScript entry.
           deps-vec (get shadow-map :dependencies [])
           cljs-vec [['org.clojure/clojurescript "1.10.914" :scope "provided"]]
           dependencies (into [] (concat cljs-vec deps-vec))
           ;; Our semantic release version; should probably be a map for
           ;; easy usage and updates.
           version "0.0.2"
           project-map {:name :com.kubelt/sdk
                        :version version
                        :description "Kubelt SDK"
                        :url "https://github.com/kubelt/kubelt"
                        :source-paths ["src/main"]
                        :dependencies dependencies
                        :repositories [["github" {:url "https://maven.pkg.github.com/kubelt/kubelt"
                                                  :creds :gpg}]]}
           project (make-project project-map)]
       (spit output-path project)))}

  pack:cljs:project
  {:doc "Generate a ClojureScript JAR file using Leiningen"
   :depends [generate:cljs:project]
   :task
   (let [project-file (str (fs/path "project.clj"))]
     (shell "lein jar"))}

  publish:cljs
  {:doc "Publish the SDK as a ClojureScript package"
   :depends [pack:cljs:project #_pack:cljs:deps]
   :task (shell "lein deploy github")}

  publish:clj
  {:doc "Publish the SDK as a Clojure package"
   :task
   (do
     (println "not yet implemented")
     (System/exit 1))}}}
