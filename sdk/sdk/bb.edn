{:paths []
 :deps {uberdeps/uberdeps {:mvn/version "1.1.2"}}
 :min-bb "0.7.0"
 :tasks
 {:requires
  [[babashka.classpath :as cp]
   [babashka.fs :as fs]
   [babashka.process :as bpr]
   [clojure.edn :as edn]
   [clojure.java.io :as io]
   [clojure.set :as cs]
   [clojure.string :as str]]
  :init
  ;; TODO version increment during releases
  ;; TODO Check for package.json version discrepancies
  (do
    ;; Add shared build code to classpath.
    (cp/add-classpath "../bb")
    (require '[com.kubelt.build :as kb])
    ;; Extract version from package.json.
    (def version (kb/package-version "package.json"))
    ;; Get the path to the SDK root.
    (def sdk-root (str (fs/canonicalize ".."))))
  ;;:enter
  ;;:leave

  package:version
  {:doc "Print out the package.json version"
   :task (println version)}

  ;; Compare the dependencies in parent package.json and local
  ;; package.json For any deps that intersect, make sure they have the
  ;; same version. Note that this only detects the error when the
  ;; necessary dependencies are present in both files; if a dependency
  ;; is missing we can't currently detect that.
  package:check
  {:doc "Check for package.json version discrepancies"
   :task (let [pkg-parent (str (fs/file sdk-root "package.json"))
               pkg-local (str (fs/file "." "package.json"))
               mismatches (kb/package-mismatches pkg-parent pkg-local)]
           (when (not (empty? mismatches))
             (throw (ex-info "mismatched versions" mismatches))))}

  build:js:develop
  {:doc "Build a development JavaScript version of the SDK"
   :depends [package:check]
   :task (shell {:dir sdk-root} "npx shadow-cljs compile sdk")}

  build:js:release
  {:doc "Build a release JavaScript version of the SDK"
   :depends [package:check]
   :task (shell {:dir sdk-root} "npx shadow-cljs release sdk")}

  build:develop
  {:doc "Run all the builds"
   :depends [build:js:develop]}
  
  build:release
  {:doc "Build all the SDK release packages"
   :depends [build:js:release]}

  pack:js
  {:doc "Create an npm package"
   :depends [build:js:release]
   :task (shell "npm pack")}

  publish:js
  {:doc "Publish the SDK as an npm package"
   :depends [pack:js]
   :task (let [tgz-name (str/join "" ["kubelt-sdk-" version ".tgz"])
               pack-file (first (fs/glob "." tgz-name))]
           (if-not pack-file
             (throw (ex-info "missing npm package.tgz")))
           (shell "npm publish" pack-file))}

  publish:all
  {:doc "Publish all the SDK targets"
   :depends [publish:js]}

  ;; These tests require the SDK from JavaScript and exercise the
  ;; JavaScript version of the API.
  test:js:develop
  {:doc "Run tests against JavaScript development version of SDK"
   :depends [build:js:develop]
   :task (shell "node test/api-v1.js")}

  ;; These tests require the SDK from JavaScript and exercise the
  ;; JavaScript version of the API.
  test:js:release
  {:doc "Run tests against the JavaScript release version of SDK"
   :depends [build:js:release]
   :tasks (shell "node test/api-v1.js")}

  ;; Using uberdeps to generate the JAR from a generated deps.edn
  ;; includes Clojure class files, which aren't needed to distribute a
  ;; CLJS library. Try another jar packing tool; in the interim we
  ;; generate a project.clj and rely on lein.
  generate:cljs:deps
  {:doc "Generate a deps.edn from shadow-cljs.edn"
   :task
   (letfn [(to-deps-edn [[k v]]
             [k {:mvn/version v}])]
     (let [shadow-path (str (fs/path sdk-root "shadow-cljs.edn"))
           output-path (str (fs/path sdk-root "deps.edn"))
           ;; Extract dependencies from shadow-cljs.edn
           shadow-reader (java.io.PushbackReader. (io/reader shadow-path))
           shadow-map (edn/read shadow-reader)
           deps-vec (get shadow-map :dependencies [])
           deps-map (into {} (map to-deps-edn deps-vec))
           ;; Build a deps.edn file
           deps-edn {:paths ["src/main"]
                     :dependencies deps-map}]
       (spit output-path (pr-str deps-edn))))}

  pack:cljs:deps
  {:doc "Generate a ClojureScript JAR file using Uberdeps"
   :depends [generate:project]
   :task
   (let [deps-file (str (fs/path sdk-root "deps.edn"))
         output-file "kubelt-sdk.jar"
         parts ["-M" "-m" "uberdeps.uberjar" "--deps-file" deps-file "--target" output-file]
         command (str/join " " parts)]
     (clojure command))}

  ;; TODO generate Apache Maven .m2/settings.xml include GitHub package
  ;; repository setup. User will have to specify their username and
  ;; personal access token and put the file into the right spot.

  ;; TODO generate $HOME/.npmrc configuration

  ;; This is pretty gross. Prefer the deps.edn-based solution once we
  ;; figure out how to generate a JAR with no Clojure dependencies.
  generate:cljs:project
  {:doc "Generate a project.clj from shadow-cljs.edn"
   :task
   (let [project-map
         {:name :com.kubelt/sdk
          :version version
          :description "Kubelt SDK"
          :url "https://github.com/kubelt/kubelt"
          :source-paths ["src/main"]
          :repositories [["github" {:url "https://maven.pkg.github.com/kubelt/kubelt"
                                    :creds :gpg}]]}
         shadow-path (str (fs/path sdk-root "shadow-cljs.edn"))
         output-path (str (fs/path "project.clj"))
         ;; The Leiningen project.clj file as a string.
         project-clj (kb/shadow->lein project-map shadow-path)]
     (spit output-path project-clj))}

  pack:cljs:project
  {:doc "Generate a ClojureScript JAR file using Leiningen"
   :depends [generate:cljs:project]
   :task
   (let [project-file (str (fs/path "project.clj"))]
     (shell "lein jar"))}

  publish:cljs
  {:doc "Publish the SDK as a ClojureScript package"
   :depends [pack:cljs:project #_pack:cljs:deps]
   :task (shell "lein deploy github")}

  publish:clj
  {:doc "Publish the SDK as a Clojure package"
   :task
   (do
     (println "not yet implemented")
     (System/exit 1))}}}
