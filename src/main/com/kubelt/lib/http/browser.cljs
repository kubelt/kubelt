(ns com.kubelt.lib.http.browser
  "Support for HTTP requests from a browser execution context."
  {:copyright "Â©2022 Kubelt, Inc." :license "UNLICENSED"}
  (:require-macros
    [cljs.core.async.macros :refer [go]])
  (:require
    [clojure.string :as str]
    [cljs.core.async :as async :refer [<!]])
  (:require
    [goog.net.XhrIo :as xhrio]
    [goog.structs :as structs]
    [goog.Uri.QueryData :as query]
    [malli.core :as malli]
    [malli.error :as me])
  (:require
    [com.kubelt.lib.http.media-type :as http.media-type]
    [com.kubelt.lib.http.shared :as http.shared]
    [com.kubelt.lib.json :as lib.json]
    [com.kubelt.proto.http :as proto.http]
    [com.kubelt.spec.http :as spec.http]))


;; Public
;; -----------------------------------------------------------------------------
;; Takes a core.async channel on which the result should be placed, and
;; the response object generated by receipt of the upstream response.
(defn on-response
  [c ^ServerResponse res]
  ;; TODO inspect result type
  ;; TODO decode body
  (let [status-code (.-statusCode res)
        headers (.-headers res)
        response {:http/status status-code
                  :http/headers headers}
        body-chan (async/chan)]
    (.on res "data"
         (fn [data]
           (async/go
             (async/>! body-chan data))))
    (.on res "end"
         (fn []
           (async/go
             (async/take! body-chan
                          (fn [body]
                            ;; TODO more generic response type handling
                            ;; TODO give user option of getting JS object, avoiding conversion
                            (let [headers (js->clj headers)
                                  data-edn (cond
                                             (http.media-type/text? headers)
                                             body
                                             (http.media-type/json? headers)
                                             (lib.json/from-json body true)
                                             :else body)]
                              (async/go
                                (async/>! c data-edn)
                                (async/close! c))))))))))

(defrecord HttpClient []
  proto.http/HttpClient
  (request!

    [this m]
    (prn {:hereiam "browser-http" :request m})
;;    (if-not (malli/validate spec.http/request m)
      ;; TODO report an error using common error reporting
      ;; functionality (anomalies).
      (let [explain (-> spec.http/request (malli/explain m) me/humanize)
            error {:com.kubelt/type :kubelt.type/error
                   :error explain}
            response-chan (async/chan)
            ; build url
            method (http.shared/request->method m)
            ;; TODO check method and send post or get
            scheme (http.shared/request->scheme m)
            domain (http.shared/request->domain m)
            port (http.shared/request->port m)
            path (http.shared/request->path m)
            headers (http.shared/request->headers m)
            body (http.shared/request->body m)
            url (str/join "" [scheme "://" domain ":" port path ])]

        (prn url)
        (xhrio/send
          url
          )
        response-chan)))
;; The request map is valid, so fire off the request.


(comment 
  "request map example"
  {:kubelt/type :kubelt.type/uri
   :http/method method
   :http/version version
   :http/headers headers
   :http/trailers trailers
   :http/status status
   :http/body body
   :uri/scheme scheme
   :uri/port port
   :uri/path path
   :uri/fragment fragment
   :uri/query query
   :uri/domain domain
   :uri/user user}
  )
